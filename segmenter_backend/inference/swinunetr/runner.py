"""
### SwinUNETR Inference Runner

Provides functionalities related to running the SwinUNETR inference on the input data.
"""


import subprocess
from pathlib import Path
import torch
from typing import Any, List


def run_infer_swinunetr(
    input_path: Path,
    output_folder: Path,
    challenge: Any,
    folds: List[int] = [0, 1, 2, 3, 4]
) -> List[Path]:
    """Run SwinUNETR inference on the provided input data.

    This function executes the SwinUNETR inference script for each specified fold,
    using the appropriate pretrained model weights, and collects the paths to the
    resulting probability npz files.

    Args:
        input_path (Path): Path to the folder containing the 4 input files.
        output_folder (Path): Path to the folder to store the npz files.
        challenge (Any): The challenge identifier or related parameter.
        folds (List[int], optional): List of fold indices to process. Defaults to [0, 1, 2, 3, 4].

    Returns:
        List[Path]: List of paths to the npz files generated by inference.
    """
    pretrained_name = 'best_model.pt'
    npz_folder_list: List[Path] = []

    for fold in folds:
        # Determine the epoch based on fold
        if fold in [3, 4]:
            e = 1000
        else:
            e = 650

        # Define the path to the pretrained model
        pretrained_path = Path(f"/tmp/swinunetr_e{e}_f{fold}_b1p4/")

        # Load arguments from the pretrained model
        args = torch.load(pretrained_path / pretrained_name)['args']

        # Define the output directory for this fold
        output_dir = output_folder / f"swinunetr3d_f{fold}"
        npz_folder_list.append(output_dir)

        # Construct the command to run the SwinUNETR inference
        cmd = 'python swinunetr/inference.py'
        cmd = ' '.join((cmd, f"--datadir='{str(input_path)}'"))
        cmd = ' '.join((cmd, f"--exp_path='{str(output_dir)}'"))
        cmd = ' '.join((cmd, f'--roi_x={args.roi_x}'))
        cmd = ' '.join((cmd, f'--roi_y={args.roi_y}'))
        cmd = ' '.join((cmd, f'--roi_z={args.roi_z}'))
        cmd = ' '.join((cmd, f'--in_channels={args.in_channels}'))
        cmd = ' '.join((cmd, f'--out_channels={args.out_channels}'))
        cmd = ' '.join((cmd, '--spatial_dims=3'))
        cmd = ' '.join((cmd, '--use_checkpoint'))
        cmd = ' '.join((cmd, '--feature_size=48'))
        cmd = ' '.join((cmd, '--infer_overlap=0.625'))
        cmd = ' '.join((cmd, '--cacherate=1.0'))
        cmd = ' '.join((cmd, '--workers=0'))
        cmd = ' '.join((cmd, f'--pretrained_model_name={pretrained_name}'))
        cmd = ' '.join((cmd, f'--pretrained_dir={str(pretrained_path)}'))
        cmd = ' '.join((cmd, '--pred_label'))

        print(cmd)
        subprocess.run(cmd, shell=True)  # Executes the command in the shell

    # Generate list of npz paths based on output folders
    npz_path_list = [f / f"{input_path.name}-t1n.npz" for f in npz_folder_list]
    return npz_path_list
